PYTHON:
1)Определение базовой проверки (Base Case):
Если длина строки равна нулю или один символ, то строка уже перевёрнута, и её можно вернуть без изменения.if len(s) <= 1:    return s
2)Описание рекурсивного шага (Recursive Step):
Для строки большего размера выполняем два этапа:a. Получаем последний символ строки (s[-1]).b. Вызываем рекурсивно функцию для строки без последнего символа (s[:-1]).c. Соединяем полученный результат: последний символ плюс перевернутая оставшаяся часть строки.Например, если строка "привет", то рекурсивный вызов выполнится так:
"т" + reverse_string("приве")
Далее: "те" + reverse_string("прив")
Потом: "тер" + reverse_string("при")
И так далее, пока не дойдем до базовых случаев.
3) Возврат финального результата:
Финальный результат формируется последовательным соединением символов, полученных на каждом уровне рекурсии.

Результат алгоритма:Введенная строка: привет 
Перевёрнутая строка: тевирп

Временная сложность: O(n). 
Суммарно получается, что каждое обращение рекурсии производит операцию порядка O(k), где kk — длина текущей подстроки, и поскольку число обращений равно числу символов в строке, итоговая временная сложность — O(n).
Это связано с тем, что общая сумма длин подстрок равна сумме чисел от 1 до n, однако с точки зрения асимптотического анализа мы игнорируем постоянные множители и получаем порядок роста O(n). 

C++
Описание:
1)	Проверка базовой ситуации: если строка пустая или состоит из одного символа, возвращаем её как есть (базовый случай).
2.	Разделение строки: запоминаем первый символ строки, удаляя его временно.
3.	Рекурсивный вызов: повторяем процедуру переворота для остаточной части строки.
4.	Объединение результатов: после завершения рекурсии добавляем запомненный первый символ в конец строки.
Синтаксис:
1. void reverseString(string& str) {
2	   if (str.length() <= 1) return;          // Базовый случай
3	   char firstChar = str.front();           // Запоминаем первый символ
4      str.erase(str.begin());                 // Удаляем первый символ
6.	  reverseString(str);                     // Рекурсивный вызов
7.	  str.push_back(firstChar);               // Возвращаем символ в конец
8.	}
Временная сложность: O(n)
Итоговая временная сложность определяется общей работой с символами строки и количеством уровней рекурсии, дающих в итоге линейную зависимость от размера строки: O(n)

JAVA:
Описание:
1.	Базовый случай: если строка пустая или состоит из одной буквы, возвращаем её как есть.
2.	Рекурсивный случай: берём первый символ строки и перемещаем его в конец, после чего рекурсивно обращаем остальные символы.
Синтаксис:
o	substring(1) — извлекает строку без первого символа.
o	charAt(0) — получает первый символ строки.

Временная сложность: O(n)
Таким образом, несмотря на наличие рекурсии, фактическое время выполнения обусловлено числом операций, необходимых для прохода по каждому символу строки, что приводит к линейной зависимости от длины строки. Именно поэтому временная сложность такого алгоритма равна O(n)



Контрольный вопрос 7:
Временная сложность задачи о N ферзях
Время выполнения алгоритма бэктрекинга зависит от числа потенциальных решений, которые приходится проверить. Обычно задача решается за экспоненциальное время, точнее говоря, сложность задачи можно оценить как O(N!)
O(N!) (факториальная сложность).

Почему именно факториальная сложность?

Фундаментальная причина — размещение ферзя на каждом следующем столбце ограничивает возможное расположение ферзей на дальнейших столбцах. По сути, каждый следующий шаг сужает пространство возможных решений, но изначально количество возможностей растёт экспоненциально.
Детали алгоритма:
Пусть у нас доска размером N×N. Мы начинаем размещать ферзей постолбцово.Для первого столбца доступно NN позиций.Во втором столбце уже будут заблокированы некоторые клетки предыдущими размещениями, но потенциально остаётся около (N−1) клеток.Этот процесс продолжается, и для следующего столбца свободных мест будет ещё меньше.Таким образом, грубо говоря, количество комбинаций, которые придется рассмотреть, приближается факториалу числа N, так как на каждом этапе число возможных выборов уменьшается на единицу.Поэтому наиболее точное утверждение о временной сложности задачи о N ферзях звучит так: решение находится за время O(N!)
O(N!), так как алгоритм должен проверить большинство из N! возможных способов разместить ферзей.
